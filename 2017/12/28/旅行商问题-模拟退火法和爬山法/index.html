<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我随便写，你随便看。"><title>旅行商问题-模拟退火法和爬山法 | Ciaran Chen 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=UA-125805814-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-125805814-1');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '264aaaa76ee702a5b65385936f19abeb';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">旅行商问题-模拟退火法和爬山法</h1><a id="logo" href="/.">Ciaran Chen 的博客</a><p class="description">随便写写。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">旅行商问题-模拟退火法和爬山法</h1><div class="post-meta">2017-12-28</div><div class="post-content"><p>模拟退火法和爬山法都是启发式算法，也就是说，他们的目的不在于寻找最优解，而是在寻找最优解和成本之间找到平衡。这适用于一些计算机难解问题。比如说旅行商问题。</p>
<span id="more"></span>

<p>本文数据下载自： <a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/a280.tsp.gz">http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/a280.tsp.gz</a><br>模拟退火的代码： <a href="https://gist.coding.net/u/feanor/a8e2351ce0fb44578f7c0181f28bd846">https://gist.coding.net/u/feanor/a8e2351ce0fb44578f7c0181f28bd846</a><br>爬山法的代码：<a href="https://gist.coding.net/u/feanor/d061dac114fd4b6fb44268bb48da1d0b">https://gist.coding.net/u/feanor/d061dac114fd4b6fb44268bb48da1d0b</a></p>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>数据文件前六行为声明、最后一行为EOF字符。中间每行有三个数字：第一个为节点的编号、第二三个为节点的横纵坐标。则读取文件数据的函数可以类似这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">filename=<span class="string">&#x27;../data/a280.tsp&#x27;</span></span>):</span><br><span class="line">    lines = <span class="built_in">open</span>(filename).readlines()</span><br><span class="line">    line = [line.strip().split() <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">6</span>:-<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">int</span>(words[<span class="number">1</span>]), <span class="built_in">int</span>(words[<span class="number">2</span>])) <span class="keyword">for</span> words <span class="keyword">in</span> line]</span><br></pre></td></tr></table></figure>

<p>这样读出了数据的坐标并作为一个列表。</p>
<h2 id="求距离"><a href="#求距离" class="headerlink" title="求距离"></a>求距离</h2><p>求距离矩阵以表示节点之间的距离；使用python自带的itertools中的笛卡尔积函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">distances</span>(<span class="params">points</span>):</span><br><span class="line">    num = <span class="built_in">len</span>(points)</span><br><span class="line">    distance = [math.sqrt(((x[<span class="number">0</span>] - y[<span class="number">0</span>])**<span class="number">2</span> + (x[<span class="number">1</span>] - y[<span class="number">1</span>])**<span class="number">2</span>)) <span class="keyword">for</span> x, y <span class="keyword">in</span> product(points, points)]</span><br><span class="line">    <span class="keyword">return</span> np.resize(distance, [num, num])</span><br></pre></td></tr></table></figure>

<h2 id="选取一定数量的点"><a href="#选取一定数量的点" class="headerlink" title="选取一定数量的点"></a>选取一定数量的点</h2><p>优化算法都需要说的是，它们并不会比较所有的点，它们只选择其中的一部分进行比较。然后我们就需要构造一个这样的集合：当点的数量多的时候，取得多；点的数量少的时候取得少。这样基本就是正比关系。但是当最后几个数字时候我们则很难取到…：</p>
<p>（说实话，这里的逻辑其实简单粗暴地我不太想写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next</span>(<span class="params">indexs</span>):</span><br><span class="line">    num = <span class="built_in">len</span>(indexs)</span><br><span class="line">    nextnum = num // <span class="number">10</span>  <span class="keyword">if</span> num &gt;= <span class="number">10</span> <span class="keyword">else</span> num</span><br><span class="line">    <span class="keyword">return</span> random.sample(indexs, nextnum)</span><br></pre></td></tr></table></figure>


<h2 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h2><p>爬山法的主要逻辑就是给一堆点。然后每次都选取离我最近的点，然后这样我每一步都是最短的，最后遍历完的时候至少也是比较短的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_step</span>(<span class="params">distances, curnode, next_list</span>):</span><br><span class="line">    maxcost = <span class="number">100000</span></span><br><span class="line">    retnode = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> next_list:</span><br><span class="line">        <span class="keyword">if</span> distances[curnode][node] &lt; maxcost:</span><br><span class="line">            maxcost = distances[curnode][node]</span><br><span class="line">            retnode = node</span><br><span class="line">    <span class="keyword">return</span> retnode, maxcost</span><br></pre></td></tr></table></figure>

<p>然后算法的主要逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hill_climb</span>(<span class="params">distances</span>):</span><br><span class="line">    num = np.size(distances, <span class="number">1</span>)</span><br><span class="line">    selected = []</span><br><span class="line">    indexs = <span class="built_in">list</span>(<span class="built_in">range</span>(num))</span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## init the loop</span></span><br><span class="line">    item = random.choice(indexs)</span><br><span class="line">    selected.append(item)</span><br><span class="line">    indexs.remove(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num-<span class="number">1</span>):</span><br><span class="line">        next_list = get_next(indexs)</span><br><span class="line"></span><br><span class="line">        curnode = selected[-<span class="number">1</span>] <span class="comment">## the last node of the selected</span></span><br><span class="line">        nextnode, maxcost = next_step(distances, curnode, next_list)</span><br><span class="line"></span><br><span class="line">        sum_cost += maxcost</span><br><span class="line">        indexs.remove(nextnode)</span><br><span class="line">        selected.append(nextnode)</span><br><span class="line">    <span class="keyword">return</span> selected, sum_cost</span><br></pre></td></tr></table></figure>

<h2 id="模拟退火法"><a href="#模拟退火法" class="headerlink" title="模拟退火法"></a>模拟退火法</h2><p>模拟退火法主要逻辑就是不是每个都取最近的点，给概率会接受选取其它的点。然后是对这个概率做文章：最开始这个概率很大，到后来这个就干脆不接受了。这就是模拟退火算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_step</span>(<span class="params">dist, curnode, next_list, temp</span>):</span><br><span class="line">    t_min = <span class="number">60</span>  <span class="comment">## 最小温度</span></span><br><span class="line">    max_cost = <span class="number">100000</span> <span class="comment">## 初始最大代价</span></span><br><span class="line">    retnode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> next_list:</span><br><span class="line">        <span class="keyword">if</span> dist[curnode][node] &lt; max_cost:</span><br><span class="line">            max_cost = dist[curnode][node]</span><br><span class="line">            retnode = node</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment">## 有一定概率接受新的节点</span></span><br><span class="line">            <span class="keyword">if</span> temp &gt; t_min \</span><br><span class="line">                <span class="keyword">and</span> math.exp((dist[curnode][node] - max_cost) / temp) &gt; random.uniform(<span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">                retnode = node</span><br><span class="line">                max_cost = dist[curnode][node]</span><br><span class="line">                <span class="keyword">return</span> (retnode, max_cost)</span><br><span class="line">    <span class="keyword">return</span> (retnode, max_cost)</span><br></pre></td></tr></table></figure>

<p>然后算法的主要逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_anneal</span>(<span class="params">distances</span>):</span><br><span class="line">    num = np.size(distances, <span class="number">1</span>)</span><br><span class="line">    indexs = <span class="built_in">list</span>(<span class="built_in">range</span>(num))</span><br><span class="line">    path = []</span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    item = random.choice(indexs)</span><br><span class="line">    path.append(item)</span><br><span class="line">    indexs.remove(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num-<span class="number">1</span>):</span><br><span class="line">        next_indexs = get_next(indexs)</span><br><span class="line"></span><br><span class="line">        curnode = path[-<span class="number">1</span>]</span><br><span class="line">        nextnode, maxcost = next_step(distances, curnode, next_indexs, temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update statement</span></span><br><span class="line">        temp *= <span class="number">0.98</span>  <span class="comment">## 退火</span></span><br><span class="line">        sum_cost += maxcost</span><br><span class="line">        indexs.remove(nextnode)</span><br><span class="line">        path.append(nextnode)</span><br><span class="line">    <span class="keyword">return</span> path, sum_cost</span><br></pre></td></tr></table></figure>

<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>因为旅行商问题是遍历所有点的最短路径，所以只要直接将选出的最短路画出来，也就确保所有点都在纸上了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pic_visualization</span>(<span class="params">path, points</span>):</span><br><span class="line">    plt.legend()</span><br><span class="line">    x = [points[p][<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> path]</span><br><span class="line">    y = [points[p][<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> path]</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="效果比较"><a href="#效果比较" class="headerlink" title="效果比较"></a>效果比较</h2><h3 id="不画图的效率比较"><a href="#不画图的效率比较" class="headerlink" title="不画图的效率比较"></a>不画图的效率比较</h3><p>爬山法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time python tsp.py</span><br><span class="line">最合适的路径为：</span><br><span class="line"> [183, 161, 180, 156, 157, 150, 151, 152, 155, 176, 179, 137, 138, 263, 204, 209, 211, 251, 208, 210, 206, 212, 215, 222, 224, 233, 226, 225, 216, 203, 217, 229, 231, 239, 273, 3, 10, 278, 247, 249, 246, 232, 248, 256, 205, 250, 228, 279, 0, 259, 252, 264, 133, 270, 15, 12, 272, 14, 258, 257, 276, 4, 9, 13, 11, 6, 131, 21, 124, 29, 28, 26, 128, 129, 20, 135, 147, 146, 149, 141, 142, 140, 268, 269, 132, 153, 31, 127, 120, 125, 34, 35, 38, 47, 59, 57, 63, 116, 56, 43, 48, 45, 64, 115, 65, 69, 73, 74, 76, 80, 97, 103, 87, 105, 107, 172, 173, 170, 102, 88, 93, 90, 96, 95, 166, 101, 171, 109, 104, 79, 77, 72, 86, 62, 117, 60, 85, 70, 75, 84, 81, 167, 174, 158, 148, 177, 145, 139, 134, 261, 267, 198, 144, 197, 202, 201, 143, 196, 195, 185, 186, 192, 178, 159, 119, 175, 181, 190, 99, 169, 189, 191, 164, 163, 111, 108, 82, 61, 83, 55, 46, 50, 53, 39, 36, 51, 44, 67, 42, 27, 126, 25, 122, 118, 114, 68, 49, 37, 40, 58, 71, 193, 136, 130, 123, 52, 110, 187, 200, 154, 121, 19, 30, 18, 274, 244, 230, 214, 221, 236, 241, 7, 242, 243, 260, 266, 24, 41, 17, 16, 5, 271, 265, 275, 235, 254, 199, 182, 165, 162, 168, 188, 106, 78, 245, 238, 237, 240, 277, 213, 219, 184, 255, 113, 92, 22, 112, 66, 207, 220, 223, 160, 33, 234, 23, 8, 89, 91, 253, 98, 94, 100, 54, 32, 262, 2, 1, 227, 218, 194]</span><br><span class="line">最小花费为：12272.288796</span><br><span class="line">python3 tsp.py  0.84s user 0.18s system 82% cpu 1.239 total</span><br></pre></td></tr></table></figure>

<p>模拟退火法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time python tsp.py</span><br><span class="line">最合适的路径为：</span><br><span class="line">[116, 192, 78, 5, 131, 278, 179, 276, 188, 69, 212, 41, 61, 256, 273, 70, 209, 59, 44, 220, 67, 114, 216, 93, 8, 154, 228, 234, 239, 229, 233, 223, 222, 218, 207, 249, 242, 1, 3, 260, 261, 265, 135, 149, 150, 118, 120, 126, 28, 127, 130, 26, 27, 20, 18, 123, 30, 19, 134, 266, 147, 140, 144, 145, 193, 196, 197, 204, 208, 254, 248, 252, 253, 139, 267, 16, 132, 270, 12, 271, 272, 7, 274, 268, 263, 136, 133, 128, 29, 21, 24, 125, 122, 119, 156, 113, 81, 88, 87, 85, 109, 84, 82, 111, 102, 101, 171, 172, 162, 164, 185, 191, 195, 201, 202, 200, 194, 187, 184, 189, 173, 96, 108, 76, 94, 95, 80, 104, 79, 98, 91, 106, 159, 157, 183, 161, 174, 180, 176, 86, 56, 55, 58, 117, 112, 90, 97, 74, 66, 62, 83, 99, 160, 151, 175, 163, 100, 77, 168, 103, 75, 71, 57, 43, 47, 45, 54, 63, 49, 68, 72, 89, 92, 107, 110, 169, 64, 105, 60, 46, 48, 50, 36, 35, 38, 51, 52, 53, 153, 155, 25, 129, 152, 177, 178, 158, 42, 17, 14, 10, 205, 141, 146, 264, 148, 137, 142, 215, 214, 217, 232, 231, 224, 230, 255, 251, 226, 210, 203, 143, 138, 259, 11, 13, 121, 262, 9, 6, 243, 279, 250, 219, 213, 199, 227, 245, 2, 241, 4, 269, 275, 277, 221, 246, 198, 166, 170, 73, 34, 32, 23, 31, 15, 240, 258, 244, 236, 238, 22, 33, 39, 167, 211, 225, 181, 0, 165, 206, 124, 182, 186, 190, 115, 65, 40, 37, 257, 247, 237, 235]</span><br><span class="line">最小花费为：14381.296207</span><br><span class="line">python3 tsp.py  0.92s user 0.27s system 76% cpu 1.560 total</span><br></pre></td></tr></table></figure>

<h3 id="二者产生的路径"><a href="#二者产生的路径" class="headerlink" title="二者产生的路径"></a>二者产生的路径</h3><p>爬山法：</p>
<p><img src="/images/hill_climb_tsp.png"></p>
<p>模拟退火法：</p>
<p><img src="/images/simulated_annealing_tsp.png"></p>
<h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><p>贪心法其实跟爬山法是一样的：每次选出最好的结果，但是在贪心法里面是对所有数据进行比较的。</p>
<p>因此它花费的时间会比启发式算法慢，但是它的结果肯定会好不少。这里就用它的结果作为好的对比。</p>
<pre><code>$ python tsp.py
最合适的路径为：
 [108, 88, 80, 79, 78, 75, 74, 73, 72, 71, 70, 69, 66, 65, 64, 63, 62, 61, 117, 60, 59, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 30, 29, 124, 123, 122, 121, 120, 119, 118, 156, 157, 158, 159, 174, 160, 161, 162, 163, 164, 165, 166, 167, 168, 100, 99, 98, 97, 92, 93, 94, 95, 96, 91, 90, 89, 103, 102, 101, 169, 170, 171, 172, 105, 104, 106, 107, 109, 110, 113, 112, 86, 83, 82, 81, 87, 111, 114, 116, 115, 85, 84, 57, 56, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 58, 67, 68, 76, 77, 173, 181, 180, 175, 176, 150, 151, 155, 152, 154, 153, 128, 127, 20, 19, 18, 17, 16, 132, 131, 130, 129, 126, 125, 28, 27, 26, 25, 21, 24, 22, 23, 13, 12, 11, 10, 9, 7, 6, 8, 274, 273, 272, 271, 270, 15, 14, 269, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 177, 178, 179, 182, 183, 184, 186, 185, 188, 187, 189, 190, 191, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 250, 249, 246, 243, 240, 239, 238, 237, 230, 231, 232, 233, 234, 235, 236, 245, 244, 242, 241, 1, 279, 2, 278, 277, 3, 276, 275, 5, 4, 0, 247, 248, 255, 254, 251, 252, 253, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 31, 192]
最小花费为：3116.016610
</code></pre>
<p>路径可视化：</p>
<p><img src="/images/greedy_tsp.png"></p>
<h2 id="为什么要写这么一个东西"><a href="#为什么要写这么一个东西" class="headerlink" title="为什么要写这么一个东西"></a>为什么要写这么一个东西</h2><p>因为我在网上搜到了一篇错误的教程，里面出现的代码不但错误，而且思想也不对。我愿想做一个更深入地了解的，但是期末已经临近了，博客还是暂时少花一点时间为妙。于是想着就算是纯贴代码也好了，于是就有了这篇博客。如果您也吃过错误教程的亏，您应该会明白我感到愤怒的原因。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%A8%A1/" rel="tag">数模</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul></div><div class="post-nav"><a class="pre" href="/2017/12/31/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">2017年终总结</a><a class="next" href="/2017/12/05/%E6%95%B0%E5%80%BC%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/">数值线性代数1</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.ciaran.cn"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p></p><a class="info-icon" href="mailto:ciaranchen@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/ciaranchen" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E6%9C%AF/">学术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%AF%E6%B7%A1/">扯淡</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/">科学计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Plotly/" style="font-size: 15px;">Plotly</a> <a href="/tags/Cygwin/" style="font-size: 15px;">Cygwin</a> <a href="/tags/CORS/" style="font-size: 15px;">CORS</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/LaTeX/" style="font-size: 15px;">LaTeX</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/tags/OpenWrt/" style="font-size: 15px;">OpenWrt</a> <a href="/tags/OpenClash/" style="font-size: 15px;">OpenClash</a> <a href="/tags/Mirai/" style="font-size: 15px;">Mirai</a> <a href="/tags/scanner/" style="font-size: 15px;">scanner</a> <a href="/tags/source-code/" style="font-size: 15px;">source code</a> <a href="/tags/%E9%97%B2%E8%B0%88/" style="font-size: 15px;">闲谈</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/bridge/" style="font-size: 15px;">bridge</a> <a href="/tags/NixOS/" style="font-size: 15px;">NixOS</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/lisp/" style="font-size: 15px;">lisp</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/ipython/" style="font-size: 15px;">ipython</a> <a href="/tags/jupyter/" style="font-size: 15px;">jupyter</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/utools/" style="font-size: 15px;">utools</a> <a href="/tags/%E4%BB%A3%E6%95%B0/" style="font-size: 15px;">代数</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Zotero/" style="font-size: 15px;">Zotero</a> <a href="/tags/javascript%EF%BC%8C-URLScheme/" style="font-size: 15px;">javascript， URLScheme</a> <a href="/tags/%E5%8F%A4%E6%96%87/" style="font-size: 15px;">古文</a> <a href="/tags/%E6%B0%B4/" style="font-size: 15px;">水</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 15px;">配置</a> <a href="/tags/assemble/" style="font-size: 15px;">assemble</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%95%B0%E6%A8%A1/" style="font-size: 15px;">数模</a> <a href="/tags/sqlmap/" style="font-size: 15px;">sqlmap</a> <a href="/tags/OllyDbg/" style="font-size: 15px;">OllyDbg</a> <a href="/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/" style="font-size: 15px;">数值计算</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/05/12/%E5%9C%A8Firefox%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">在Firefox中添加自定义搜索引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/29/%E6%94%BF%E5%BA%9C%E8%B4%A2%E6%8A%A5%E8%A7%A3%E8%AF%BB(1)/">政府财报解读（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/16/utools%E5%AD%A6%E6%9C%AF%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">utools学术小工具介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/15/%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6Zotero%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%93%BE%E6%8E%A5/">快速复制Zotero项目的链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/24/OpenClash%E9%85%8D%E7%BD%AE/">OpenClash 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/%E6%81%A2%E5%A4%8D%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/">恢复更新博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/NixOS%E9%85%8D%E7%BD%AE%E7%BD%91%E6%A1%A5/">NixOS 配置网桥</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/%E5%AD%90%E4%B8%8D%E9%81%93%E7%88%B6%E4%B9%8B%E8%BF%87%E5%87%BA%E5%A4%84%E8%80%83/">子不道父之过出处考</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/%E7%AE%80%E5%8D%95sqlmap%E6%B3%A8%E5%85%A5/">简单sqlmap注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/%E7%AE%80%E5%8D%95%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">简单缓冲区溢出</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://de_licious.gitlab.io/physics_math_fun/" title="de_licious" target="_blank">de_licious</a><ul></ul><a href="http://www.saberismywife.com/" title="SaberDa" target="_blank">SaberDa</a><ul></ul><a href="http://www.stephenzhang.me/" title="StephenZhang" target="_blank">StephenZhang</a><ul></ul><a href="http://blog.boileryao.com/" title="Boiler Yao" target="_blank">Boiler Yao</a><ul></ul><a href="http://hilvcha.github.io/" title="Hilvcha" target="_blank">Hilvcha</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Ciaran Chen 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho. </a><a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn">陕ICP备17013427号</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>